import uuid
from datetime import timedelta, datetime
from typing import Union, Optional, List

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from jose import jwt, JWTError
from passlib.context import CryptContext

from sqlalchemy import select

from .models import DBUser, TokenData, SchemaUserCreate, SchemaUser, SchemaUserFull
from ..db import get_db
from ..setting import get_settings

setting = get_settings()
SECRET_KEY = setting.secret_key
ALGORITHM = setting.algorithm
ACCESS_TOKEN_EXPIRE_MINUTES = setting.access_token_expire_minutes

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


async def get_user(username: str, db=Depends(get_db)) -> Optional[DBUser]:
    user = await db.execute(select(DBUser).where(DBUser.username == username).limit(1))
    return user.scalars().one_or_none()


async def add_user(create: SchemaUserCreate, db=Depends(get_db)) -> DBUser:
    user = DBUser(**create.model_dump(exclude={'password'}),
                  id=uuid.uuid4(),
                  hashed_password=get_password_hash(create.password),
                  registered_at=datetime.utcnow(),
                  )
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return user


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)


async def authenticate_user(username: str, password: str, db=Depends(get_db)):
    user = await get_user(username, db)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def user_factory(is_activate: bool = False, is_superuser: bool = False, scopes: Optional[List[str]] = None):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    async def _get_current_user(token: str = Depends(oauth2_scheme), db=Depends(get_db)) -> SchemaUserFull:

        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            username: str = payload.get("sub")
            if username is None:
                raise credentials_exception
            token_data = TokenData(username=username)
        except JWTError:
            raise credentials_exception
        user = await get_user(token_data.username, db)
        user.accessed_at = datetime.utcnow()
        await db.commit()
        if user is None:
            raise credentials_exception
        return SchemaUserFull.model_validate(user)

    async def func(user=Depends(_get_current_user)) -> SchemaUser:
        if is_activate and not user.is_active:
            raise credentials_exception

        if is_superuser and not user.is_superuser:
            raise credentials_exception

        if scopes:
            if not user.scopes:
                raise credentials_exception
            if not all(scope in user.scopes for scope in scopes):
                raise credentials_exception

        return SchemaUser.model_validate(user)

    return func


get_current_user = user_factory()

get_current_super_user = user_factory(is_superuser=True)

get_current_active_user = user_factory(is_activate=True)
